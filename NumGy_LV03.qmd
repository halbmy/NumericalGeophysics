---
title: "Numerical Simulation Methods in Geophysics, Part 3: Time-stepping"
subtitle: "1. MGPY+MGIN, 3. MDRS+MGEX-CMG"
author: "thomas.guenther@geophysik.tu-freiberg.de"
title-slide-attributes:
  data-background-image: pics/tubaf-logo.png
  data-background-size: 20%
  data-background-position: 10% 95%
format:
  tubaf-revealjs:
    html-math-method: mathjax
    chalkboard: true
    include-in-header:
        - text: |
            <script>
            window.MathJax = {
            loader: {
                load: ['[tex]/physics']
            },
            tex: {
                packages: {'[+]': ['physics', 'textcomp']}
            }
            };
            </script>
    slide-number: c/t
    transition: fade
    transition-speed: fast
    menu:
      side: left
# jupyter: python3
---

# Recap

* Poisson's equation, solved with FD in 1D
* boundary conditions determine shift (Dirichlet) and flow (Neumann)
* no sources: linear potential (constant flow)
* sources: positive curvature (max), continuous: parabola
* slope changes with conductivity ($a$ contrasts act like source)

## FD in 2D: discretization

:::: {.columns}
::: {.column}
::: {.r-stack}
$\nabla$ operator in $x$ and $y$ direction

![Simple 2D conductivity grid](pics/grid32a.svg)

![Simple 2D conductivity grid with FD stencil](pics/grid32stencil.svg){.fragment}
:::
:::
::: {.column}
:::: {.fragment}
$$ C_{i,j}^{right} = a_{i,j-\textonehalf} / (x_{i+1}-x_{i})^2 $$

$a_{i,j-\textonehalf}=(a_{i,j-1}+a_{i,j})/2$ ?

harmonic, geometric? weighting?

$a_{i,j-\textonehalf}=\frac{a_{i,j-1}\Delta y_{j-1}+a_{i,j}\Delta y_{j}}{y_j+1-y_{j-1}}$?
::::
:::
::::

## FD in 3D: discretization
:::: {.columns}
::: {.column}
![3D discretization](pics/fd3ddiscr.png)
:::
::: {.column}
![coupling coefficient ](pics/fd3d_ctop.png)
:::
::::

## Solution of Poisson's equation in 1D/2D/3D

* point source (fundamental solution = Greens function)
* 1D: flow is constant (cannot spread)
* 2D: flow distributes on circle circumference (constant $a$)
$$q(r)=\frac{Q}{2\pi r} \quad\Rightarrow\quad u=-\frac{Q\rho}{2\pi}\ln r$$
* 3D: flow distributes on sphere surface
$$j(r)=\frac{I}{4\pi r^2} \quad\Rightarrow\quad u=\frac{I\rho}{4\pi r}$$

## Spatial 2D and 3D solutions

:::: {.columns}
::: {.column}
![2D solution (-ln r)](NB/u2d.svg){width="100%"}
:::
::: {.column}
![3D solution (1/r)](NB/u3d.svg){width="100%"}
:::
::::

## Comparison of 2D and 3D solutions
![](NB/u2d3d.svg)

# Parabolic PDEs

* describe diffusion problems (of potential fields)
* second spatial and first temporal derivative, e.g. in 1D
$$ \pdv{T}{t} - a \pdv[2]{T}{z} = \div\bf q_s $$

## Heat flow in 1D

:::: {.columns}
::: {.column width="60%"}

temperature gradient $\Delta T$ $\Rightarrow$ heat flow

$$ Q/\Delta t = \frac{k A}{L} \Delta T $$

$$\vb q = -\frac1A \pdv{Q}{t} = - k \pdv{T}{z} $$

cannot disappear (divergence 0)

$$\div\vb q = -\div (k \grad T) = \div \vb q_s$$

:::
::: {.column width="40%"}
![](pics/heatResistor.png)

* $T$ [K], $A$ [m²], $L$ [m]
* $Q$ [J/m/K], $q$ [W/m²]
* $k$ [W/m] thermal conduct.

:::
::::

## Heat conduction equation

:::: {.columns}
::: {.column width="55%"}
$$ \dv{Q_z}{z} \dd z = \dv{q_z}{z} \dd z \dd x \dd y \dd t = k \dv[2]{T}{z} \dd V \dd t $$

with the heat capacity $c_p$ [W/kg/K]
$$ c_p m \dd T = c_p \rho \dd V \dd T $$ $\Rightarrow$ heat conduction equation
$$ \dv{T}{t} - \frac{k}{\rho c_p} \dv[2]{T}{z} = Q_s $$
:::
::: {.column width="45%"}
![](pics/heatCube.png)
:::
::::

## Instationary heat flow in 3D

$$ \pdv{T}{t} - \div a \grad T = \div q_s $$

* $a=\frac{k}{\rho c_p}$ [m²/s] thermal diffusivity - measure of heat transfer
* $k$ [W/m/K] thermal conductivity - measure of temperature transfer
* $c_p$ [J/kg/K] - heat capacity - measure of heat storage per mass
* $\rho$ (kg/m³) density

Water $k$=0.6 W/m/K, $\rho$=1000 kg/m³, $c$=4180 J/kg/K $\Rightarrow$ $a$=1.43e-7 m²/s

# Our first case: temperature diffusion into the Earth

## Periodic boundary conditions

:::: {.columns}
::: {.column}
Upper boundary: daily/yearly variation

$$ T(z=0) = T_0 + \Delta T \sin \omega t $$

$T_0$ mean temperature (e.g. 12°C), $\Delta T$ variation, e.g. 8°C

$\omega=2\pi/\tau$ daily ($\tau_d$=3600*24s) or yearly ($\tau_y=365 \tau_d$) cycle
:::
::: {.column}
```{python}
#| eval: true
#| echo: false
from math import sqrt, pi
import numpy as np
import matplotlib.pyplot as plt
```

```{python}
#| eval: true
#| echo: true
day = 3600 * 24
T0, dT = 12, 8
t = np.arange(100) / 50 * day
T = T0+dT*np.sin(t/day*2*np.pi)
plt.plot(t/day*24, T)
plt.xlabel("t (h)")
plt.ylabel("T (°C)")
plt.grid()
```
:::
::::

## Analytical solution

$$ \pdv{T}{t} = a\pdv[2]{T}{z} $$

$T = T_0 + \Delta t\hat{T}$ (shift and scale) $\Rightarrow$
same equation for $\hat T$

Separation of variables: $\hat{T}(t, z) = \theta(t) Z(z)$$

$$ Z \pdv{\theta}{t} = a \theta \pdv[2]{Z}{z} \quad\Rightarrow\quad
 \frac1\theta \pdv{\theta}{t} = C = a \frac{1}{Z}\pdv[2]{Z}{z} $$

## Solution

regarding the BC $e^{\imath\omega t}$ leads to $C=\imath\omega$ and thus $\theta=\theta_0 e^{\imath\omega t}$

$$ \pdv[2]{Z}{z} - \imath \frac{\omega}{a} Z = \pdv[2]{Z}{z} + n^2 Z = 0  $$

Helmholtz equation with solution $Z=Z_0 e^{\imath n z}$ ($n^2=\imath\omega/a$)

$$ Z=Z_0 e^{\imath n z} = Z_0 e^{\sqrt{\imath\omega/a}z} =
Z_0 e^{\sqrt{\omega/2a}(1+\imath)z} $$

$$ T(t, z)/\Delta T + T_0 = Z(z)\theta(t)=
Z_0\theta_0 e^{-\sqrt{\omega/2a}z} e^{i(\omega t-\sqrt{\omega/2a}z)} $$

## Interpretation

replacing the term $\sqrt{2a/\omega}=\sqrt{a \tau/\pi}=d$ leads to

$$ T(z, t) = T_0 + \Delta T e^{-z/d} \sin(\omega t - z/d) $$


* exponential damping of the temperature variation with decay depth $d$
* phase lag $z/d$ increases with depth, $z_\pi=\sqrt{2 a/\omega}\pi=\sqrt{a \tau \pi}=d \di$

1. Daily cycle: decay depth $d$=6cm, minimum depth=20cm
2. Yearly cycle: decay depth $d$=1.2m, minimum depth=4m

## Depth profiles

```{python}
#| output-location: column
#| code-line-numbers: false
#| echo: true
a = 1.5e-7
year = day*365
d = sqrt(a*year/pi)
t = np.arange(0, 1, 0.1) * year
z = np.arange(0, 6, 0.1)
fig, ax = plt.subplots()
for ti in t:
    Tz = np.exp(-z/d)*np.sin(ti*2*pi/year-
                             z/d) * dT + T0
    ax.plot(Tz, z, label="t={:.1f}".format(
        ti/year))

ax.invert_yaxis()
ax.legend()
ax.grid()
```

## Animation

<video autoplay="false" controls width="100%" loop="true">
<source src="pics/temperature.mp4">
</video>


## Temporal behaviour
```{python}
#| output-location: column
#| code-line-numbers: false
#| echo: true
t = np.arange(0, 1.01, 0.01) * year
z = np.arange(0, 3, 0.4)
fig, ax = plt.subplots()
for zi in z:
    Tt = np.exp(-zi/d)*np.sin(t*2*pi/year-
                              zi/d) * dT + T0
    ax.plot(t/year*12, Tt, label=f"z={zi:.1f}")

ax.set_xlim(0, 12)
ax.set_xlabel("t (months)")
ax.set_ylabel("T (°C)")
ax.legend()
ax.grid()
```

## Experimental temperature curves

![](pics/temperature2022-2023.svg)

## The DynaDeep project - measuring scheme
![](pics/dynadeep-scheme.jpg)

## The DynaDeep project - temperature over time
![](pics/dynadeep-temp.png)


# Time-stepping with FD

$$ \pdv{u}{t} - a \pdv[2]{u}{z} = 0 $$

Finite-difference approximation ($^n$ means time step $n$)

$$ \pdv{u}{t}^n \approx \frac{u^{n+1}-u^n}{\Delta t} = a \pdv[2]{u^n}{z} $$

## Explicit (forward) Euler method

:::: {.columns}
::: {.column}
Start $T^0$ with initial condition

Update field by
$$ u^{n+1} = u^n + a \pdv[2]{u^n}{z} \cdot \Delta t $$

E.g. by using the matrix $\vb A$:

$$\vb u^{n+1}=\vb u^n-\Delta t \vb A \vb u^n=(\vb I - \Delta t \vb A)\vb u^n$$
:::
::: {.column}
```{python}
#| eval: true
#| echo: false

import pygimli as pg
import pygimli.meshtools as mt
grid = mt.createGrid(5, 4)
ax, cb = pg.show(grid)
ax.set_yticks([])
ax.plot([1, 2, 3], [1, 1, 1], "bo-", ms=12, lw=4)
ax.plot([2, 2], [1, 2], "g-", lw=4)
ax.plot(2, 2, "ro", ms=12)
ax.set_ylabel("")
ax.set_xticks([1, 2, 3])
ax.set_xticklabels([r"$x_{i-1}$", r"$x_i$", r"$x_{i+1}$"])
ax.set_yticks([1, 2])
ax.set_yticklabels([r"$t^n$", r"$t^{n+1}$"])
ax.yaxis.tick_right()
```
:::
::::

## Implicit (backward) Euler method

:::: {.columns}
::: {.column}
$$ \pdv{u}{t}^{n+1} \approx \frac{u^{n+1}-u^n}{\Delta t} = a \pdv[2]{u}{z} ^{n+1} $$

$$ \frac{1}{\Delta t} u^{n+1} - a \pdv[2]{u}{z}^{n+1} = \frac{1}{\Delta t} u^n $$

$$ (\vb I + \Delta t \vb A) \vb u^{n+1} = \vb u^n $$

Solving an equation system
:::
::: {.column}
```{python}
#| eval: true
#| echo: false

grid = mt.createGrid(5, 4)
ax, cb = pg.show(grid)
ax.set_yticks([])
ax.plot([1, 2, 3], [2, 2, 2], "bo-", ms=12, lw=4)
ax.plot([2, 2], [1, 2], "go-", ms=12, lw=4)
ax.plot(2, 2, "ro", ms=12)
ax.set_ylabel("")
ax.set_xticks([1, 2, 3])
ax.set_xticklabels([r"$x_{i-1}$", r"$x_i$", r"$x_{i+1}$"])
ax.set_yticks([1, 2])
ax.set_yticklabels([r"$t^n$", r"$t^{n+1}$"])
ax.yaxis.tick_right()
```
:::
::::

## Mixed (Crank-Nicholson) method

$$ \pdv{u}{t}^{n+\textonehalf} \approx \frac{u^{n+1}-u^n}{\Delta t} = \frac12 a \pdv[2]{u}{z} ^n + \frac12 a \pdv[2]{u}{z} ^{n+1} $$

:::: {.columns}
::: {.column width="65%"}
$$ \frac{2}{\Delta t} u^{n+1} - a \pdv[2]{u^{n+1}}{z} =
   \frac{2}{\Delta t} u^n + a \pdv[2]{u^n}{z} $$

$$ (2\vb I + \Delta t\vb A) \vb u^{n+1} = (2\vb I - \Delta t \vb A) \vb u^n $$

<!-- $$ \pdv{T}{t}^n \approx \frac{T^{n+1}-T^n}{\Delta t} = \frac12 a \pdv[2]{T}{z} ^n + \frac12 a \pdv[2]{T}{z} ^{n+1} $$ -->
:::
::: {.column width="35%"}
```{python}
#| eval: true
#| echo: false

grid = mt.createGrid(5, 4)
ax, cb = pg.show(grid)
ax.set_yticks([])
ax.plot([1, 2, 3], [1, 1, 1], "bo-", ms=12, lw=4)
ax.plot([1, 2, 3], [2, 2, 2], "bo-", ms=12, lw=4)
ax.plot([2, 2], [1, 2], "g-", ms=12, lw=4)
ax.plot(2, 2, "ro", ms=12)
ax.set_ylabel("")
ax.set_xticks([1, 2, 3])
ax.set_xticklabels([r"$x_{i-1}$", r"$x_i$", r"$x_{i+1}$"])
ax.set_yticks([1, 2])
ax.set_yticklabels([r"$t^n$", r"$t^{n+1}$"])
ax.yaxis.tick_right()
```
:::
::::

