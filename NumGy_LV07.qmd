---
title: "Numerical Simulation Methods in Geophysics, Part 7: 2D Poisson issues"
subtitle: "1. MGPY+MGIN"
author: "thomas.guenther@geophysik.tu-freiberg.de"
title-slide-attributes:
  data-background-image: pics/tubaf-logo.png
  data-background-size: 20%
  data-background-position: 10% 95%
format:
  tubaf-revealjs:
    html-math-method: mathjax
    chalkboard: true
    include-in-header:
        - text: |
            <script>
            window.MathJax = {
            loader: {
                load: ['[tex]/physics']
            },
            tex: {
                packages: {'[+]': ['physics']}
            }
            };
            </script>
    slide-number: c/t
    transition: slide
    transition-speed: fast
    menu:
      side: left
# jupyter: python3
---
## Recap

* finite differences approximate partial derivatives
* finite elements approximate solution $\Rightarrow$ preferred
* spatial discretization determines accuracy of solution
* implicit & mixed time-stepping schemes accurate & stable
* basic elements in 1D/2D/3D & higher order shape functions
* numerical integration , e.g. by Gaussian quadrature

## Inner vs. outer nodes

distinguish dofs into inner and outer $\mqty[\vb u_i, \vb u_o]^T$

$$ \vb A = \mqty(\vb A_{ii} & \vb A_{io}\\
                 \vb A_{oi} & \vb A_{oo}) $$

$\vb A \mqty[\vb u_i \\ \vb u_o] = \mqty[\vb f_i \\ \vb f_o]$

$$ \Rightarrow \vb A_{ii} \vb u_i = \vb f_i - \vb A_{oi} \vb u_o $$

## Green's functions

The Green's function $G$ is the solution for a Dirac source $\delta$
$$ \mathfrak{L} G = \delta(\vb r) $$
The solution can then be obtained by convolution
$$ u(\vb r) = G(\vb r-\vb r')*f(\vb r') = $$

# Secondary field approach

* singular or highly nonlinear source field
  - i.e. $1/r$ behaviour of potential fields from point sources
* boundary conditions require *far-away* boundaries
* well-known field (*primary field*) for background

## Solution of Poisson's equation in 1D/2D/3D

* point source (fundamental solution = Greens function)
* 1D: flow is constant (cannot spread)
* 2D: flow distributes on circle circumference (constant $a$)
$$q(r)=\frac{Q}{2\pi r} \quad\Rightarrow\quad u=-\frac{Q\rho}{2\pi}\ln r$$
* 3D: flow distributes on sphere surface
$$j(r)=\frac{I}{4\pi r^2} \quad\Rightarrow\quad u=\frac{I\rho}{4\pi r}$$

## Spatial 2D and 3D solutions

:::: {.columns}
::: {.column}
![2D solution (-ln r)](NB/u2d.svg){width="100%"}
:::
::: {.column}
![3D solution (1/r)](NB/u3d.svg){width="100%"}
:::
::::

## Comparison of 2D and 3D solutions
![](NB/u2d3d.svg)

## Direct current resistivity

$$ \div \sigma\grad u = -\div \vb j_s $$

See notebook for problems

## Secondary field approach

$$ -\div \sigma\grad u = \div \vb j_s $$

$u$ for $\sigma$=const: $u_0=u(\sigma_0)=\frac{I}{2\pi\sigma_0}$ fulfils eq.

Idea: split $\sigma$ solution in $u=u_0+u_a$

<!-- $$ \div (\sigma_0+\sigma_a)\grad (u_0+u_a) = -\div \vb j_s $$ -->
<!-- -\div \sigma\grad (u_0+u_a)= -->
$$ -\div\sigma\grad u_0-\div\sigma\grad u_a = \div \vb j_s=-\div\sigma_0\grad u_0 $$

$$ \Rightarrow -\div\sigma\grad u_a = \div (\sigma-\sigma_0)\grad u_0 $$

Anomalies *secondary* sources:
$\vb A^\sigma\vb u_a=-\vb A^{\delta\sigma}\vb u_0=(\vb A^{\sigma_0}-\vb A^{\sigma})\vb u_0$


# 2D/3D problems
Make use of pyGIMLi

See documentation on [pyGIMLi.org](https://pygimli.org)

## The meshtools module
```{python}
#| echo: true
#| eval: true
import pygimli as pg
import pygimli.meshtools as mt
world = mt.createWorld(start=[-10000, -10000], end=[10000, 0])
pg.show(world, boundaryMarkers=True)
```

## The meshtools module
```{python}
#| echo: true
#| eval: true
mesh = mt.createMesh(world, quality=34, area=1e5)
pg.show(mesh)
```

## Creating a 2D geometry
```{python}
#| echo: true
#| eval: true
anomaly = mt.createRectangle(start=[0, -8000], end=[1000, -1000], marker=2)
pg.show(world+anomaly)
```

## Creating a 2D mesh
```{python}
#| echo: true
#| eval: true
mesh = mt.createMesh(world+anomaly, quality=34, smooth=True, area=1e5)
pg.show(mesh, markers=True, showMesh=True);
```


## Creating a 2D conductivity model
```{python}
#| echo: true
#| eval: true
sigma0 = 1 / 100  # 100 Ohmm
sigma = mesh.populate("sigma", {1: sigma0, 2: sigma0*10})
pg.show(mesh, "sigma", showMesh=True);
```

## The solver module


## The solver module
```{python}
#| echo: false
#| eval: true
import matplotlib.pyplot as plt
import numpy as np
```

```{python}
#| echo: true
#| eval: true
import pygimli.solver as ps
mesh["my"] = 4 * np.pi * 1e-7
A = ps.createStiffnessMatrix(mesh, a=1/mesh["my"])
M = ps.createMassMatrix(mesh, mesh["sigma"])
fig, ax = plt.subplots(ncols=2)
ax[0].spy(pg.utils.toCSR(A), markersize=1)
ax[1].spy(pg.utils.toCSR(M).todense(), markersize=1)
```

## The complex problem matrix

$$\vb B = \mqty(\vb A & -\omega \vb M\\ \omega \vb M & \vb A)$$

```{python}
#| echo: true
#| eval: true
#| output-location: column
w = 0.1
nd = mesh.nodeCount()
B = pg.BlockMatrix()
B.Aid = B.addMatrix(A)
B.Mid = B.addMatrix(M)
B.addMatrixEntry(B.Aid, 0, 0)
B.addMatrixEntry(B.Aid, nd, nd)
B.addMatrixEntry(B.Mid, 0, nd, scale=-w)
B.addMatrixEntry(B.Mid, nd, 0, scale=w)
pg.show(B)
```