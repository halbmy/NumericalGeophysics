---
title: "Numerical Simulation Methods in Geophysics, Lecture 9:<br/>from 1D over 2D to 3D EM"
subtitle: "1. MGPY+MGIN"
author: "thomas.guenther@geophysik.tu-freiberg.de"
title-slide-attributes:
  data-background-image: pics/tubaf-logo.png
  data-background-size: 20%
  data-background-position: 10% 95%
format:
  tubaf-revealjs:
    html-math-method: mathjax
    # chalkboard: true
    include-in-header:
        - text: |
            <script>
            window.MathJax = {
            loader: {
                load: ['[tex]/physics']
            },
            tex: {
                packages: {'[+]': ['physics']}
            }
            };
            </script>
    slide-number: c/t
    transition: fade
    transition-speed: fast
    menu:
      side: left
jupyter: python3
---
# Recap

* Maxwells equations in time- and frequency domain
* single frequency approach (decomposition)
* Helmholtz term ($\pdv[2]{u}{x}$ and $u$ term)
* $u$ term needs mass matrix (like in time-stepping)
* complex-valued matrix problem

## Inductive EM

Assume: $\omega^2\mu\epsilon<\omega\mu\sigma$,  no sources ($\div\vb j_s=0$), + vector identity
$$\curl\curl \vb F = \grad \div \vb F - \grad^2 \vb F$$
leads with $\div \vb E=0=\div\vb B$ to the vector Helmholtz PDE

$$-\laplacian{\vb E} + \imath\omega\mu\sigma \vb E=0$$

$$-\div \sigma^{-1} \nabla \vb H + \imath\omega\mu \vb H=0$$

Helmholtz equation $-\laplacian \vb H-k^2 \vb H=0$ with $k^2=-\imath\omega\mu\sigma$

## TM polarization (scalar problem)

::: {.callout-note title="Transverse magnetic (TM) mode"}
Assume the source field is oscillating perpendicular to the modelling plane, i.e.

$\vb H=[H_x, 0, 0]^T e^{\imath\omega t}$.
:::

Then the PDE holds for the scalar $H_x$ (now only $H$)

$$-\div \sigma^{-1} \grad H_x(y,z) + \imath\omega\mu H_x(y,z) = 0$$

## Halfspace solution

$$ \pdv[2]{H}{z} + k^2 H = 0 \quad\text{with}\quad k^2=-\imath\omega\mu\sigma $$

In the Earth, the solution is
$H(z)=H_0 e^{-\imath k z} \quad \partial_{zz} H=-k^2 H$

$k=\sqrt{-\imath\omega\mu\sigma} = \sqrt{\omega\mu\sigma/2} (1-\imath)=1/d (1-\imath)$

with skin depth (1/e decay) $d=\sqrt{2/\omega\mu\sigma}=\sqrt{T/\pi\mu\sigma}$ (~500$\sqrt{\rho/f}$)

$$ -\imath k = -(1+i)/d \Rightarrow H=H_0 e^{-z/d} e^{-\imath z/d} \quad \equiv\cos(\omega t-z/d)$$

## Analytical solution
```{python}
#| echo: false
#| eval: true
import numpy as np
import matplotlib.pyplot as plt

T = 0.1
w = 2 * np.pi / T
sigma0 = 1/100  # 1/100
mu = np.pi * 4e-7
k = np.sqrt(-1j*w*mu*sigma0)
z = np.arange(-10000, 00000.1, 200)
skindepth = np.sqrt(2/w/sigma0/mu)
uAna = np.exp(1j*k*z)
fig, ax = plt.subplots(ncols=4, sharey=True)
ax[0].plot(uAna.real, -z/1000)
ax[1].plot(uAna.imag, -z/1000)
ax[2].plot(np.abs(uAna), -z/1000)
phi = np.rad2deg(np.unwrap(np.angle(uAna)))
ax[3].plot(phi, -z/1000)
ax[0].set_ylabel("z (km)")
ax[0].invert_yaxis()
tits = ['Real', 'Imag', 'Abs', 'Phase']
for a, t in zip(ax, tits):
  a.set_title(t)
  a.hlines(skindepth/1000, *a.get_xlim(), ls="--", color="C1")
  a.grid()
```

# EM with finite elements

$$-\grad^2 u + \imath\omega\mu\sigma u = f$$

$$ -\int_\Omega w \grad^2 u \dd\Omega + \int_\Omega w \imath\omega\mu\sigma u \dd\Omega = \int_\Omega w f \dd\Omega $$

Gauss's integral law

$$\int_\Omega \grad w \cdot \grad u \dd\Omega + \imath\omega \int_\Omega  \mu\sigma w u \dd\Omega = \int_\Omega w f \dd\Omega $$

## Weak formulation

$u=\sum_i u_i \vb v_i$ and $w_i\in \{v_i\}$ leads to

$$\int_\Omega \grad v_i \cdot \grad v_j \dd\Omega + \imath\omega\mu \int_\Omega \sigma v_i v_j \dd\Omega = \int_\Omega v_i f \dd\Omega $$

$$\braket{\grad v_i}{\grad v_j} + \imath\omega\mu \braket{v_i}{\sigma v_j} = \braket{v_i}{f}  \qq{inner products}$$

representation by matrix-vector product $(\vb A + \imath\omega\vb M^\sigma)\vb u=\vb b$

with $A_{ij}=\braket{\grad v_i}{\grad v_j}$, $M^\sigma_{ij}=\braket{v_i}{v_j}$ and $b_i=\braket{v_i}{f}$

## The problem in 1D
use self-implemented matrices from `stiffnessMatrix1DFE` & `massMatrix1DFE`
```{python}
#| echo: true
#| eval: true
from poisson1d import stiffnessMatrix1DFE, massMatrix1DFE
T = 0.1  # 0.1
w = 2 * np.pi / T
sigma0 = 1/100  # 1/100
mu = np.pi * 4e-7
z = np.arange(-10000, 0.1, 200)
A, b = stiffnessMatrix1DFE(x=z, uR=1)
M = massMatrix1DFE(x=z, a=mu*sigma0)
AM = A + M * 1j * w
u = np.linalg.solve(AM, b)
```

## Complex or real-valued?

The complex-valued system

$$(\vb A+\imath\omega\vb M)\vb u = (\vb A+\imath\omega\vb M) (\vb u_r + \imath \vb u_i) = \vb b_r + \imath \vb b_i$$

can be transferred into a doubled real-valued system

$$\vb A\vb u_r + \imath\vb A u_i + \imath\omega\vb M \vb u_r - \omega\vb M \vb u_i = \vb b_r + \imath \vb b_i$$

$$\mqty(A & -\omega M\\ \omega M & A) \mqty(u_r\\ u_i) = \mqty(b_r\\ b_i) $$


## Complex-to-real

$$\vb B = \mqty(\vb A & -\omega \vb M\\ \omega \vb M & \vb A)$$

```{python}
#| echo: true
#| eval: true
#| output-location: column
D = np.vstack([np.hstack([A, -M*w]),
               np.hstack([M*w, A])])
plt.imshow(D)
d = np.hstack([b, b*0])
uri = np.linalg.solve(D, d)
u = uri[:len(z)] + uri[len(z):] * 1j
```

## Complex-to-real in pyGIMLi

$$\vb B = \mqty(\vb A & -\omega \vb M\\ \omega \vb M & \vb A)$$

```{python}
#| echo: false
#| eval: true
import pygimli as pg
import pygimli.meshtools as mt
import pygimli.solver as ps
world = mt.createWorld(start=[-10000, -10000], end=[10000, 0])
anomaly = mt.createRectangle(start=[0, -8000], end=[1000, -1000], marker=2)
mesh = mt.createMesh(world+anomaly, quality=34, smooth=True, area=1e5)
mesh["my"] = 4 * np.pi * 1e-7
mesh["sigma"] = sigma0
```

```{python}
#| echo: true
#| eval: true
#| output-location: column
A = ps.createStiffnessMatrix(mesh)
b = np.zeros(mesh.nodeCount())
ps.assembleBC({'Dirichlet': {-1: 1.0}},
              mesh, A,  b);
M = ps.createMassMatrix(
    mesh, mesh["sigma"]*mesh["my"])
nd = mesh.nodeCount()
B = pg.BlockMatrix()
B.Aid = B.addMatrix(A)
B.Mid = B.addMatrix(M)
B.addMatrixEntry(B.Aid, 0, 0)
B.addMatrixEntry(B.Aid, nd, nd)
B.addMatrixEntry(B.Mid, 0, nd, scale=-w)
B.addMatrixEntry(B.Mid, nd, 0, scale=w)
pg.show(B)
```

## Complex in pyGIMLi

```{python}
#| echo: true
#| eval: true
C = pg.matrix.CSparseMatrix(A.vecColPtr(), A.vecRowIdx(),
    pg.core.toComplex(A.vecVals(), M.vecVals()*w))
c = pg.core.toComplex(b, b*0)
u = ps.linSolve(C, c).array()  # important (bug in pyGIMLi!)
```

![](pics/helmholtz1D.svg)

## Secondary field for EM
Let $E_0$ be the solution to the equation for $\sigma=\sigma_0$
$$-\grad^2 E_0 +\imath\omega\mu\sigma_0 E_0=0$$

and $E=E_0+E_a$ for $\sigma=\sigma_0+\delta\sigma$

$$-\grad^2 (E_0 + E_a) +\imath\omega\mu(\sigma_0+\delta\sigma) (E_0+E_a)=0$$
subtracting leads to
$$-\grad^2 E_a +\imath\omega\mu(\sigma_0+\delta\sigma) E_a=-\imath\omega\mu\delta\sigma E_0$$


## Secondary field for EM

$$ -\grad^2 E_a + \imath\omega\mu\sigma E_a = -\imath\omega\mu\delta\sigma E_0 $$

::: {.callout-note}
Source terms only arise at anomalous conductivities and increase with primary field
:::

is solved for $E_0$($\vb u$) using $\vb A$-stiffness, $\vb M$-mass and $E_0$($\vb u_0$)

$$ (\vb A + \imath\omega\vb M_\sigma) \vb u = -\imath\omega\vb M_{\delta\sigma} \vb u_0 $$

```{python}
#| echo: true
#| eval: false
A = stiffnessMatrix1DFE(x=z)
M = massMatrix1DFE(x=z, a=w*mu*sigma)
dM = massMatrix1DFE(x=z, a=w*mu*(sigma-sigma0))
u = uAna + solve(A+M*w*1j, dM@uAna * w*1j)
```

# EM vector modelling

$$ \curl \mu^{-1}\curl \vb E + \imath\omega\sigma\vb E - \omega^2\epsilon \vb E = -\imath\omega \vb j_s$$

$$ \curl \sigma^{-1} \curl \vb H + \imath\omega\mu\vb H - \omega^2\mu\epsilon \vb H = \curl \sigma^{-1}\vb j_s$$


## History

::: {.callout-note title="James Clerk Maxwell, Treatise on Electricity & Magnetism, 1891"}
“Physical vector quantities may be divided into two classes, in one of which
the quantity is defined with reference to a line, while in the other the quantity
is defined with reference to an area.”
:::
* integral equations (IE), finite differences (FD) and elements (FE)
* nodal and vector basis functions, secondary field
* decompose 3D source (2D inverse) in wavenumber domain
* improvement of equation solvers and preconditioners
* parallel solvers, high-performance computing

## Solving EM problems with staggered grid
![Staggered grid cell after Yee (1966)](pics/yeeCell.png){fig-align="center"}

## The way from FD to FE

![Orthogonal, non-orthogonal and irregular grids (Rücker et al., 2006)](pics/rueckerGrids.png)

## The Finite Element zoo (1D & 2D)

::: {.columns}
::: {.column width="75%"}
![Arnold (2013): Periodic table of elements](pics/element_zoo1d2d.png){fig-align="center"}
:::
::: {.column width="25%"}
* $k$=0 Nodal elements
* $k$=1 edge elements
* $k$=2 face elements (Discontinuous Galerkin)
* $r$/$p$ higher order
:::
::::

## The Finite Element zoo (3D)

![Arnold (2013): Periodic table of elements](pics/element_zoo3d.png){fig-align="center"}

## Vectorial solution for EM fields

:::: {.columns}
::: {.column}
![Schwarzbach & Haber (2013)](pics/schwarzbachHaber2013.png)
:::
::: {.column}
* $\vb E \in H^\text{curl}(\Omega)$
* $\vb B \in H^\text{div}(\Omega)$
* natural BC: Dirichlet $\vb n \cross \vb E=0$
* Neumann BC: $\vb n \cross \mu^{-1} \curl \vb E=0$
:::
::::

## Elements used in EM modelling
![Types of elements relevant for EM problems (Spitzer, 2024)](pics/EMelements.png)

## Meshing complicated geometries

![Meshing workflow in custEM (Rochlitz et al., 2019)](pics/custem/meshes.png)

## Modelling example

![Modelling example of a conductive dike (Rochlitz et al., 2019)](pics/custem/examples.png)

## Packages

Mesh generation: [TetGen](https://tetgen.org) (3D), [GMsh](https://gmsh.info) (2D/3D)

FE packages: [FEniCS](https://fenicsproject.org), [NETGEN/NGsolve](https://ngsolve.org)

Equation solvers: [Suitesparse](https://doc.sagemath.org/html/en/reference/spkg/suitesparse.html), [MUMPS](https://mumps-solver.org), [SciPy](https://scipy.org)

Computational frameworks: [PetSc](https://petsc.org), [MPI](https://www.mcs.anl.gov/research/projects/mpi/)

EM modelling (and inversion) packages: [Mare2DEM](https://mare2dem.bitbucket.io), [emg3d](https://emg3d.emsig.xyz), GoFEM, [PETGEM](https://petgem.bsc.es/), [custEM](https://custem.readthedocs.io), [SimPEG](https://simpeg.xyz), ModEM, FEMTIC

# Boundary conditions

## Mixed boundary conditions
So far...

* Dirichlet Boundary conditions $u=u_0$
* Neumann Boundary conditions $\pdv{u}{n}=g_B$<br>
* for vectorial problems $\vb n\cdot \vb E=0$ or $\vb\curl \vb E=0$

In general mixed, also called Robin (or impedance convective) BC
$$ a u + b \pdv{u}{n} = c $$

## Example DC resistivity with point source
$$\div \sigma \grad u = \div \vb j = I \delta(\vb r - \vb r_s)$$

solution for homogeneous $\sigma$ on surface: $u=\frac{I}{2\pi\sigma} \frac{1}{|\vb r - \vb r_s|}$

E-field $\vb E=-\frac{I}{2\pi\sigma} \frac{\vb r - \vb r_s}{|\vb r - \vb r_s|^3}$

normal direction $\vb E \cdot \vb n=-\frac{u}{|\vb r - \vb r_s|}\cos \phi$ purely geometric

$$\pdv{u}{n} + \frac{\cos\phi}{|\vb r - \vb r_s|}=0$$

## Perfectly matched layers

::: {.columns}
::: {.column}
![](pics/FDTD_TFSF.png)
:::
::: {.column}
$$ \pdv{x} \rightarrow \frac{1}{1+i\sigma/\omega} \pdv{x}  $$

$$ x \rightarrow x + \frac{i}{\omega}\int^x \sigma(x')\dd x' $$

:::
:::


## Absorbing boundary conditions
wave equation (e.g. in 2D)
$$ \pdv[2]{u}{t} - v^2 \laplacian u = 0 $$

Fourier transform in $t$ and $y$ (boundary direction) $\Rightarrow \omega, k$

$$ \omega^2 \hat{u} - v^2 \pdv[2]{\hat{u}}{x} + v^2 k^2 \hat{u} = 0 $$

ordinary DE with solution $\hat{u}=\sum a_i e^{\lambda x}$ with $\lambda^2 = k^2 - \omega^2/v^2$

