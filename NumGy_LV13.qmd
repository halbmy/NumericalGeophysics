---
title: "Numerical Simulation Methods in Geophysics, Part 13: Summary"
subtitle: "1. MGPY+MGIN"
author: "thomas.guenther@geophysik.tu-freiberg.de"
title-slide-attributes:
  data-background-image: pics/tubaf-logo.png
  data-background-size: 20%
  data-background-position: 10% 95%
format:
  tubaf-revealjs:
    html-math-method: mathjax
    chalkboard: true
    include-in-header:
        - text: |
            <script>
            window.MathJax = {
            loader: {
                load: ['[tex]/physics']
            },
            tex: {
                packages: {'[+]': ['physics']}
            }
            };
            </script>
    slide-number: c/t
    transition: fade
    transition-speed: fast
    menu:
      side: left
jupyter: pgdev
---
# Recap

* learned basics of FD, FE and FV methods
* solved different PDE types:
  - elliptic Poisson (potential): heat, flow, DC, gravity, mag)
  - parabolic (diffusion): heat transfer, time-domain EM
  - hyperbolic (waves): seismics, GPR (just 1D)
  - elliptic Helmholtz: frequency-domain EM (or heat)
* script in development on [tubaf-em.github.io/Numerical_Simulation](https://tubaf-em.github.io/Numerical_Simulation/)

## The methods

1. The Finite Difference (FD) method
   * elliptic: Poisson equation in 1D, look into 2D/3D
   * parabolic: diffusion equation in 1D, time-stepping
   * hyperbolic: acoustic wave equation in 1D
1. The Finite Element (FE) method
   * Poisson equation in 1D & 2D
   * complex Helmholtz equation in 2D for EM problems
   * solving EM problems and computational aspects
1. The Finite volume method: just looking

## The methods

::: {.callout-tip title="The Finite Difference method"}
approximates the partial derivatives by difference quotients (beware $\Delta x$ and $\Delta a$)
:::

::: {.callout-tip title="The Finite Element method"}
approximates the solution through base functions in integrative sense
:::

::: {.callout-tip title="The Finite Volume method"}
approximates the solution by piecewise constant values and ensures conservation law by fluxes
:::

## Take-aways

1. You always get a numerical solution but it can be crap.
1. FE is the most flexible and wide-spread method.
1. FD & FV simple to implement, FV keeps continuity (transport!).
1. FD parameter weighting in 2D/3D problems $\Rightarrow$ inaccuracies
1. Spatial refinement or higher polynomial order improve accuracy, particularly at source positions with strong curvature.
1. Sometimes the boundaries need to be set really far away.
1. Secondary field computation partly overcomes the latter two.
1. Implicit or mixed time-stepping more accurate and stable than explicit

## Next-generation FE: [Oskar](https://base-fn.gitlab.io/oskar/index.html)

- built upon pyGIMLi v2.0

#### Simplest modelling example
```
from oskar ScalarSpace, VectorSpace, laplace, div, grad
s = ScalarSpace(mesh, name='T', p=2)
T = solve(-laplace(s) == 1, bc={'Dirichlet':{'*':0}})
```

#### Step by step
```
PDE = lambda u: -div(alpha*grad(u))
A, rhs = (PDE(s) == f).weakForm.assemble()
```

#### Post-processing
```
j = a * grad(u)
```



# What's left to mention?

**Accuracy**

1. Verification methods
1. Error estimation and goal-oriented refinement

## Discontinuous Galerkin method

typical for hyperbolic problems

weak form of wave equation with fluxes (FV)

$$M\partial_t q(t) - A^T q(t) = -F(a, q(t))$$
$$\Rightarrow \partial_t q=\vb M^{-1}(A^T q(t) - F(a, q(t)))$$

locally for each element & communication through fluxes (like in FV)

## Spectral element method

typically used for global wave phenomena

::: {.columns}
::: {.column}
$u=\sum u_i\phi_i(\pv r)$

$\phi$ Lagrangian polynoms $l_i^N=\prod\limits_k^N \frac{\xi-\xi_k}{\xi_i-\xi_k}$

or Chebychev polynoms
:::
::: {.column}
![First six Lagrangian polynomials](pics/Legendrepolynomials6.svg)
:::
:::

## Infinite Elements

![](pics/infiniteelements.png)

## Meshless modelling

![](pics/meshless.png)

## Meshless divergence operator (Wittke, 2017)

![](pics/meshlessDivergence.png)

## The method of exact solutions (MES)

:::: {.columns}
::: {.column}
* find domain or condition for which an analytical solution exists
* often for Dirac type sources $\Rightarrow$ solution is a **Green's function**
* integrate over Greens function for extended sources
* convergency tests (refine spatially and polynomially)

[MES example from Oskar](https://base-fn.gitlab.io/oskar/_tutorials/plot_20_mes_heat_equation.html)
:::
::: {.column}
![](pics/schwarzbach_refinement.png)
:::
::::


## The method of manufactured solutions (MMS)

* use any function or distribution for solution $\vb u$
* create right-hand-side vector $\vb f$ using FEM
* solve for $\vb u$ and compare with

[MMS example from Oskar](https://base-fn.gitlab.io/oskar/_tutorials/plot_10_mms_basics.html)

# Error estimation and mesh refinement

* get idea of accuracy of the solution
* refinement of cells with high error (e.g. large gradients)
* comparison between successive refinement solutions

## Error estimation (residual-based)

Poisson problem $-\nabla^2=f$ with bilinear form $a(u,v)=\int \grad u \grad v \dd\Omega$

finite-dimensional function space $V_h$: $a(u_h, v_h)=l(v_h)$

estimate error $e_h$ in bilinear form $a(e_h,v)=a(u, v)-a(u_h, v)$

residual $R=f+\nabla^2 u_h$ leads to $a(e_h,v)=\sum\limits_c\int\limits_{\Omega_c} R v \dd\Omega_c$

## Error estimation (recovery-based)

gradients across element boundaries tend to be discontinuous

compare original (unsmoothed) gradient of the solution with improved
$$(E_h)^2 = \int |M(u_h)-\grad u_h|^2\dd\Omega $$

$M$ obtained by smoothing over patch of elements around each element

## Goal-oriented mesh refinement

primal and dual (adjoint) problem (with receiver as hypothetical source)

inner product of solutions
$$\Phi_{lmn}=\int_{c_n} \vb F^l \vb F^m \dd\Omega_n$$


# Performance in Parallel

:::: {.columns}
::: {.column width="60%"}
* Desktop computers (1 CPU with many cores)
* fat node (shared memory) architecture
* cluster (distributed) architectures:
  - NUMA (non-uniform memory access)
:::
::: {.column width="40%"}
![&nbsp;](pics/NUMA_Architecture.png)
:::
::::


## Computational size
![](pics/EMdatasets.png){fig-align="center"}

## Amdahl's law
Distribute runtime into serial and parallel part $t=t_s+t_p/N(+t_c(N))$

![](pics/amdahl.png){fig-align="center"}

## Perfomance analysis - Memory
![](pics/presb/memoryComplexity.png){fig-align="center"}

## Perfomance analysis - Time
![](pics/presb/timeComplexity.png){fig-align="center"}

## Perfomance analysis - MPI scaling
![](pics/presb/mpiPerformance.png){fig-align="center"}

## Perfomance analysis - MPI scaling
![](pics/presb/speedup.png){fig-align="center"}

## Multiple right-hand sides
![](pics/presb/rhs.png){fig-align="center" width="50%"}


<!--
## Tips for further studying

-
- [Oskar website](https://base-fn.gitlab.io/oskar/index.html) for everything around FE
- -->